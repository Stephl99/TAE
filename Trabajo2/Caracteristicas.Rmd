---
title: "Característica"
output: html_document
---
## Funciones creadas para el problema:
```{r}
library(ggbiplot)
```
### Contar los na de una columna
```{r}
conteo <- function(columna){
  return(sum(is.na(columna)))
}
segmentar_columna <- function(columna, percentiles){
  nueva <- columna 
  nueva[nueva >0] <- findInterval(nueva[nueva>0], quantile(columna, percentiles)) + 1
  return(nueva)
}
```
### Reescalado min/max
```{r}
min_max <- function(columna){
  columna <- (columna-min(columna))/(max(columna)-min(columna))
  return(columna)
}
```
### Lectura de paquetes:
```{r}
library(tidyverse)
library(naniar)
```
### Cargar Base de datos:
```{r}
base <- readRDS("numericos.RDS")
nits <- base$nit
base <- base[, -1]
original <- base
summary(original$en_tx_canal5)
```
# PIPELINE
## Preprocesar
###Convertir los valores que son 0 a NA
```{r}
base <- log(base+1)
```
```{r}
base <- lapply(base, min_max)
base <- as.data.frame(base)
```
```{r}
base[base==0] <- NA
```
### Visualizar los NA
```{r}
valores <- apply(FUN = conteo, base, MARGIN = 2)
nombresNA <-names(sort(valores))
base <- base[, nombresNA]
```
```{r}
vis_miss(base)
```
```{r}
base[is.na(base)] <- 0
```


### Convertir valores en variables poco usadas que no son 0 en 1
```{r}
base[19:30][base[19:30] > 0] = 1
```
###
```{r}
base[1:18] <- lapply(base[1:18], segmentar_columna, 
                     percentiles = seq(0.1, 1, by = 0.1))
base <- as.data.frame(base)
```
## Kmeans
```{r}
set.seed(280721)
training <- base
wcss <- vector()
for(i in 1:15){
  wcss[i] <- sum(kmeans(training, i)$withinss)
}
```

```{r}
plot(wcss, type = "ol")
```

```{r}
set.seed(280721)
kmeans <- kmeans(training, 4, iter.max =1000, nstart = 10)
```

```{r}
clusters <- kmeans$cluster
```



```{r}
pca_training <- prcomp(base[1:18])
ggbiplot(pca_training, groups = factor(clusters ) )
```
### KMEANS

```{r}
base$clusters <- clusters
table(clusters)
```

```{r}
original[original == 0] <- NA
grupo1 <- original[which(clusters == 1), ]
grupo2 <- original[which(clusters == 2), ]
grupo3 <- original[which(clusters == 3), ]
grupo4 <- original[which(clusters == 4), ]
```

```{r}
table(base$sal_vm_otros[base$clusters == 1])
table(base$sal_vm_otros[base$clusters == 2])
table(base$sal_vm_otros[base$clusters == 3])
table(base$sal_vm_otros[base$clusters == 4])
```

Se observa que en cada grupo se presenta un comportamiento diferente entre cada canal
## Describir
###Describir cada cluster
###Sí da el tiempo usar cada cluster como variables respuesta y de ahí evaluar sí el resultado fue el deseado mediante un modelo sencillo
## Hallar valores plausibles


## Numericas:

* 0's a NA's
* Acotar el máximo (Las más grandes tratar como otra población)

## Preprocesar a 0-1 (Max-min)

## Categóricas:

* Target-Encoder

## Algorítmicas

* DBSCAN
* KNN
* UMAP

## Agregar labels:

* Análisis descriptivo, asumiendo que label es una etiqueta real y crear un modelo sencillo como knn para etiquetar una posible observación nueva.





