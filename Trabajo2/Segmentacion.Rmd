---
title: "Segmentación para una base de datos simulada"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Lectura de paquetes:

```{r}
suppressMessages(library(tidyverse))
suppressMessages(library(ggplot2))
suppressMessages(library(devtools))
suppressMessages(library(ggbiplot))
suppressMessages(library(corrplot))
suppressMessages(library(caret))
```

### Función auxiliar para transformar las variables:

Creamos una función que nos de información acerca de cual columna es la preferida en un conjunto de filas.

```{r}
asignar <- function(fila){
  return (ifelse(sum(fila)==0, 0, which(fila==max(fila))))
}
```

## Lectura de la base de datos:

```{r}
dtb <- read.csv("base.csv", sep = ";")
```

### Canales preferidos:

Se aplica la función de asignar para extraer la información acerca de cuáles son los canales preferidos en la base de datos.

```{r}
dtb <- dtb %>% mutate(en_vm_preferido=apply(dtb[2:12], 1, asignar)) %>% 
  mutate(en_tx_preferido=apply(dtb[13:23], 1, asignar)) %>%
  mutate(sal_vm_preferido=apply(dtb[24:27], 1, asignar)) %>%
  mutate(sal_tx_preferido=apply(dtb[28:31], 1, asignar))
```

### Ponderación canales salientes:

Se halla el promedio de los valores de cada fila en cada empresa en cada tipo de canal.

```{r}
dtb <- dtb %>% mutate(en_vm_ponderado=rowSums(dtb[, 2:12])/11) %>% 
  mutate(en_tx_ponderado = rowSums(dtb[, 13:23])/11) %>%
  mutate(sal_vm_ponderado = rowSums(dtb[, 24:27])/4) %>%
  mutate(sal_tx_ponderado = rowSums(dtb[, 28:31])/4)
```



### Pagos y recaudos PN y PJ

Se crean dos variables binarias, para observar sí los pagos o recaudos fueron realizados en su mayoría para personas naturales o personas jurídicas.

```{r}
dtb <- dtb %>% mutate(persona_pagos = as.numeric(dtb$pagos_pj > dtb$pagos_pn)) %>%
  mutate(persona_recaudos = as.numeric(dtb$recaudos_pj > dtb$recaudos_pn))
```

## Copia de base de datos original para un futuro análisis descriptivo:

```{r}
saveRDS(dtb, "ori.rds")
```

## Transformación logarítmica:

Ya que las variables relacionadas con los movimientos en diversos canales bancarios son variables cuya escala es muy grande, además de que se presentan observaciones cuyos valores están muy alejados de los demás, una buena solución a esto para realizar un clustering jerárquico sería el aplicar la transformación logarítmica a los datos, esto se realizará acorde a cada canal.

```{r}
dtb <- dtb[, c(1,32:length(dtb))]
indices <- (length(dtb)-2):(length(dtb)-5)
dtb[, indices] <- log(dtb[, indices]+ 1) 
```

## Estándarización de la base de datos y recoger "características":

Se estándariza la base de datos restando la media y dividiendo por la varianza, esto para evitar problemas de escala asociados a los datos.

```{r}
dtb[, 2:length(dtb)] <- scale(dtb[, 2:length(dtb)], center = TRUE, scale = TRUE)
```

## Gráfica de correlación de los datos:

Se realiza una gráfica de correlación de los datos para hallar posibles relaciones entre las variables.

```{r}
corrplot(cor(dtb[,2:length(dtb)]))
```


```{r}
plot(dtb$en_vm_ponderado, dtb$en_vm_ponderado)
```
### Intento de clustering jerarquico

```{r}
distancias <- dist(dtb[, 2:length(dtb)])
clusters <- hclust(distancias)
```

```{r}
plot(clusters)
```

```{r}
cortes <- cutree(clusters, k = 4)
table(cortes)
```

## Análisis de componentes principales de los clusters

```{r}
pca_dtb <- princomp(dtb[, 2:length(dtb)])
summary(pca_dtb)
```

###

```{r}
ggbiplot(pca_dtb, group=factor(cortes))
```
## Visualizaciones:

### Lectura de base de datos original:

```{r}
ori = readRDS("ori.RDS")
```

### Precargue de los datos en ggplot:

```{r}
gg = ggplot(data = ori)
```

### Gráfico x contra x para ver el comportamiento de las ponderaciones:

```{r}
xx = gg + aes(x=en_vm_ponderado, y = en_vm_ponderado, color = factor(cortes)) 
xx =  xx + geom_point() 
xx + xlim(0,6e9) + ylim(0, 6e9)
```

```{r}
xx + xlim(6e9, 1e10) + ylim(6e9,1e10)
```


### Boxplots para comparar el comportamiento de cada grupo en cada canal ponderado:

```{r}
require(gridExtra)
p1 = gg + aes(x=factor(cortes), y=en_vm_ponderado) + geom_boxplot() + ylim(0, 9e9)
p2 = gg + aes(x=factor(cortes), y=ori[, 53]) + geom_boxplot() + ylim(0, 500)
p3 = gg + aes(x=factor(cortes), y=ori[, 54]) + geom_boxplot() 
p4 = gg + aes(x=factor(cortes), y=ori[, 55]) + geom_boxplot() + ylim(0, 500)
grid.arrange(p1,p2,p3,p4, ncol=2)
```

```{r}
p3
```



