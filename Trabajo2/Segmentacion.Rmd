---
title: "Segmentación para una base de datos simulada"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
suppressMessages(library(tidyverse))
suppressMessages(library(ggplot2))
suppressMessages(library(devtools))
suppressMessages(library(ggbiplot))
suppressMessages(library(corrplot))
suppressMessages(library(caret))
```


## Lectura de la base de datos:

```{r}
dtb <- read.csv("base.csv", sep = ";")
dtb[32:length(dtb)] <- lapply(dtb[32:length(dtb)], factor)
```


## Verificación de NA's:
```{r}
sum(is.na(dtb))
```
###Cálculo de distancias:
```{r}
scaled_variables <- scale(dtb[, 2:31], center =TRUE, scale = TRUE)
distances <- dist(scaled_variables, diag= TRUE)
```

###Distancias entre todas las variables:
```{r}
#image(t(as.matrix(distances)))

```
## Reescalado de la base de datos:

```{r}
scaled_dtb <- dtb
scaled_dtb[,2:31] <- scaled_variables
```



```{r}
dim(scaled_dtb)
#cluster_h <- hclust(scaled_dtb, method = "complete")
```
## Creación de bases de datos acorde al tipo de transacción y tipo de producto:

```{r}
dtb1 <- scaled_dtb[, 2:31]
dtb2 <- scaled_dtb[, 32:length(dtb)]
```


## Análisis descriptivo de los datos:

```{r}
correlations <- cor(dtb1)
corrplot(correlations)
```



```{r}
corr1 <- cor(dtb1)
```

```{r}
corrplot(corr1)
```

## Análisis de componentes principales:

```{r}
dtb1_pca <- princomp(dtb1)
ggbiplot(dtb1_pca, group=dtb2$tiene_ventas_fisicas) + ylim(-1,1) + xlim(-1,1)
```


```{r}
indices <- sample(2232, 500)
test_dtb <- dtb1[indices,]
```


```{r}
htest <- hclust(distances)
```


```{r}
plot(htest)
```

