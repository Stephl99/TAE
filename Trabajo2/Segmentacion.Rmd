---
title: "Segmentación para una base de datos simulada"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
suppressMessages(library(tidyverse))
suppressMessages(library(ggplot2))
suppressMessages(library(devtools))
suppressMessages(library(ggbiplot))
suppressMessages(library(corrplot))
suppressMessages(library(caret))
```
Función auxiliar para transformar las variables:

```{r}
asignar <- function(fila){
  return (ifelse(sum(fila)==0, 0, which(fila==max(fila))))
}
```

Función auxiliar para segmentar:

```{r}
segmentar_fila <- function(fila, percentiles){
  ## Segmenta una fila según el número de percentiles dados
  
  ## Argumentos:
  ## fila: Una fila de datos
  ## Percentiles: Percentiles por los cuales se quiere clasificar los datos
  
  ## Retorno
  ## fila_segmentada: Fila segmentada por percentiles
  
  fila_segmentada = cut(fila, quantile(fila, probs = percentiles),
                        include.lowest = TRUE, dig.lab = 999, labels = FALSE)
  
  return(as.numeric(fila_segmentada))
}
```



## Lectura de la base de datos:

```{r}
dtb <- read.csv("base.csv", sep = ";")
```

### Canales preferidos:

```{r}
dtb <- dtb %>% mutate(en_vm_preferido=apply(dtb[2:12], 1, asignar)) %>% 
  mutate(en_tx_preferido=apply(dtb[13:23], 1, asignar)) %>%
  mutate(sal_vm_preferido=apply(dtb[24:27], 1, asignar)) %>%
  mutate(sal_tx_preferido=apply(dtb[28:31], 1, asignar))
```

### Ponderación canales salientes:

```{r}
# dtb <- dtb %>% mutate(en_vm_ponderado=segmentar_fila(rowSums(dtb[, 2:12])/11, percentiles = seq(0, 1 ,by=0.2))) %>% 
#   mutate(en_tx_ponderado = segmentar_fila(rowSums(dtb[, 13:23])/11, percentiles = seq(0, 1 ,by=0.2))) %>%
#   mutate(sal_vm_ponderado = segmentar_fila(rowSums(dtb[, 24:27])/4, percentiles = seq(0, 1 ,by=0.2))) %>%
#   mutate(sal_tx_ponderado = segmentar_fila(rowSums(dtb[, 28:31])/4, percentiles = seq(0, 1 ,by=0.2)))
```

```{r}
dtb <- dtb %>% mutate(en_vm_ponderado=rowSums(dtb[, 2:12])/11) %>% 
  mutate(en_tx_ponderado = rowSums(dtb[, 13:23])/11) %>%
  mutate(sal_vm_ponderado = rowSums(dtb[, 24:27])/4) %>%
  mutate(sal_tx_ponderado = rowSums(dtb[, 28:31])/4)
```


### Pagos y recaudos PN y PJ

```{r}
dtb <- dtb %>% mutate(persona_pagos = as.numeric(dtb$pagos_pj > dtb$pagos_pn)) %>%
  mutate(persona_recaudos = as.numeric(dtb$recaudos_pj > dtb$recaudos_pn))
```


## Transformación logarítmica:

```{r}
dtb <- dtb[, c(1,32:length(dtb))]
indices <- (length(dtb)-2):(length(dtb)-5)
dtb[, indices] <- log(dtb[, indices]+ 1) 
```

## Reescalado de la base de datos y recoger "características":

```{r}
dtb[, 2:length(dtb)] <- scale(dtb[, 2:length(dtb)], center = TRUE, scale = TRUE)
```


```{r}
corrplot(cor(dtb[,2:length(dtb)]))
```


```{r}
plot(dtb$en_vm_ponderado, dtb$en_vm_ponderado)
```
### Intento de clustering jerarquico

```{r}
distancias <- dist(dtb[, 2:length(dtb)])
clusters <- hclust(distancias)
```

```{r}
plot(clusters)
```

```{r}
cortes <- cutree(clusters, k = 4)
table(cortes)
```

## Análisis de componentes principales de los clusters

```{r}
pca_dtb <- princomp(dtb[, 2:length(dtb)])
summary(pca_dtb)
```

###

```{r}
ggbiplot(pca_dtb, group=factor(cortes))
```

```{r}

```




